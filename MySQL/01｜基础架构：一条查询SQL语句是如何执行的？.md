## 01｜基础架构：一条查询SQL语句是如何执行的？

```sql
select * from T where ID = 10;
```

**MySQL的基本逻辑架构**

![IMG_052565171928-1.jpeg](https://s2.loli.net/2022/04/11/GH5mEDVeuXtl8h9.jpg)

MySQL大体分为**Server层**和**存储引擎层**两个部分

Server层包括**连接器、查询缓存、分析器、优化器、执行器**等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。

存储引擎层负责**数据的存储和提取**。插件式，支持InnoDB（默认）、MyISAM、Memory等多个存储引擎。

engine=memory指定内存引擎创建表，存储引擎共用一个Server层。

------

**连接器**

跟客户端建立连接、获取权限、维持和管理连接

```shell
mysql -h$ip -P$port -u$user -p
mysql -u root -p
```

mysql 客户端工具：跟服务端建立连接（TCP）

连接器认证通过，到权限表查出你拥有的权限（该连接此后的权限判断逻辑依赖）。

即 已经存在连接的权限不会受到影响，只有建立新的连接才会发生变更。空闲连接自动断开。（wait_timeout 默认8小时）

长连接指连接成功后客户端持续请求，使用同一连接，短连接执行完几次查询就断开，下次查新重新建立一次连接。建立连接的过程通常比较复杂，**尽量使用长连接**。

MySQL占用内存涨得特别快？因为MySQL在执行过程中**临时使用的内存是管理在连接对象里面的**，断开时释放。

解决方案：

1. 定期断开长连接。
2. mysql_reset_connection 重新初始化连接资源

------

**查询缓存**

之前是否执行过？其语句和结果以键值对（key-value）的形式被直接缓存在内存中。

弊大于利？查询缓存的失效非常频繁。对于更新压力大的数据库来说，查询缓存的命中率会非常低。

query_cache_type设置成DEMAND，默认SQL语句都不使用查询缓存。确定使用可以用SQL_CACHE显式指定。

> MySQL 8.0直接将查询缓存删掉了 哈哈哈

------

**分析器**

真正执行语句，对SQL语句做解析。

词法分析+语法分析，根据词法分析的结果，语法分析器根据语法规则，判断输入的SQL语句是否满足MySQL语法。

**"You have an error in your SQL syntax"**

------

**优化器**

表里有多个索引的时候，决定使用哪个索引；一个语句多表关联（join）的时候，决定各表的**连接顺序**（执行效率会不同）。

执行方案最终在此阶段确定

------

**执行器**

判断对表有无执行查询的权限，若有权限，就打开表继续执行。打开表的时候，执行器会**根据表的引擎定义，去使用这个引擎使用的接口**。

第一次调用“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。

while(hasNext()){}
